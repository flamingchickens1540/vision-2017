import org.opencv.core.*;
import org.opencv.imgproc.*;
import org.opencv.videoio.VideoCapture;
import org.opencv.calib3d.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class Main {
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    public static void main(String[] args) {

        // Create instance of an image processing pipeline generated by GRIP (must end with filterContours?!?!)
        ContoursPipeline pipeline = new ContoursPipeline();

        // Distortion coefficients and camera matrix for the webcam on my computer
        // TODO: Write calibration program to calculate and load these automatically
        Mat cameraMatrix = Mat.eye(3, 3, CvType.CV_64F);
        cameraMatrix.put(0, 0, 492.27331);
        cameraMatrix.put(1, 1, 492.14526);
        cameraMatrix.put(0, 2, 327.04178);
        cameraMatrix.put(1, 2, 202.45735);
        cameraMatrix.put(2,2,1.0);
        MatOfDouble distCoeffs = new MatOfDouble(0.0426968969, -0.0503434464, -0.0003085729, 0.0001547382, 0);

        // Coordinates of vertices for a sample rectangle
        MatOfPoint3f objectPoints = new MatOfPoint3f(
                new Point3(2.064, 3.4925, 0.0),
                new Point3(-2.064, 3.4925, 0.0),
                new Point3(2.064, -3.4925, 0.0),
                new Point3(-2.064, -3.4925, 0.0)
                );

        MatOfPoint3f linePoints = new MatOfPoint3f(
                new Point3(0, 0, 0),
                new Point3(2, 0, 0),
                new Point3(0, 2, 0),
                new Point3(0, 0, 2));

        // Start the usb camera with the index n
        VideoCapture camera = new VideoCapture(0);

        // Create a window for displaying the output
        ImageDisplayWindow window = new ImageDisplayWindow("Quad Finder Output", 1000, 1000);

        Mat frame = new Mat();
        while (true) {
            camera.read(frame); // Take a picture with the camera
            pipeline.process(frame); // Process with the image with GRIP pipeline

            // Filter contours with four vertices
            List<MatOfPoint> quads = Util.filterPoly(pipeline.filterContoursOutput(),4, 10);
            // TODO: filter quadrilaterals with the wrong length to width ratio
            // TODO: filter non-convex quadrilaterals

            Imgproc.drawContours(frame, quads, -1, new Scalar(0, 0, 255), 3);

            // TODO: solve for the position of ALL rectangles in image
            if (quads.size()>=1) {
                for (MatOfPoint quad : quads) {

                    List<Point> quadVert = new ArrayList<>();
                    for (Point point : quad.toArray()) {
                        quadVert.add(point);
                    }
                    quadVert.sort((lhs, rhs) -> (int) (lhs.y - rhs.y));
                    if (quadVert.get(3).x>quadVert.get(2).x) {
                        quadVert.add(2,quadVert.remove(3));
                    }
                    if (quadVert.get(1).x>quadVert.get(0).x) {
                        quadVert.add(0,quadVert.remove(1));
                    }

                    Mat rvec = new Mat();
                    Mat tvec = new Mat();
                    Calib3d.solvePnP(objectPoints, new MatOfPoint2f(quadVert.toArray(new Point[quadVert.size()])), cameraMatrix, distCoeffs, rvec, tvec, false, Calib3d.CV_ITERATIVE);
//                    System.out.println("[" + tvec.get(0, 0)[0] + ", " + tvec.get(1, 0)[0] + ", " + tvec.get(2, 0)[0] + "]");

                    MatOfPoint2f linePoints2d = new MatOfPoint2f();
                    Calib3d.projectPoints(linePoints, rvec, tvec, cameraMatrix, distCoeffs, linePoints2d);
                    Imgproc.line(frame, linePoints2d.toArray()[0], linePoints2d.toArray()[1], new Scalar(0, 0, 255), 1);
                    Imgproc.line(frame, linePoints2d.toArray()[0], linePoints2d.toArray()[2], new Scalar(255, 0, 0), 1);
                    Imgproc.line(frame, linePoints2d.toArray()[0], linePoints2d.toArray()[3], new Scalar(0, 255, 0), 1);
                }
            }
            window.updateImage(Util.matToBufferedImage(frame, null));
        }
//        camera.release();
        // TODO: figure out how to release the camera when the window is closed
    }
}
